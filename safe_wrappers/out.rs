/* automatically generated by rust-bindgen 0.55.1 */

mod bindgen_bindings {
    #![allow(dead_code, non_snake_case, non_camel_case_types, non_upper_case_globals, improper_ctypes)]
pub type std_size_t = ::std::os::raw::c_ulong;
pub type std_nullptr_t = *const ::std::os::raw::c_void;
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
pub type std___bool_constant = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___type_identity {
    pub _address: u8,
}
pub type std___type_identity_type<_Type> = _Type;
pub type std___type_identity_t = std___type_identity;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___or_ {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___or__open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___or_>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std___or_))
    );
    assert_eq!(
        ::std::mem::align_of::<std___or_>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___or_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_std___and__open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___and_>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(std___and_))
    );
    assert_eq!(
        ::std::mem::align_of::<std___and_>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___and_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___not_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___success_type {
    pub _address: u8,
}
pub type std___success_type_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___failure_type {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___failure_type() {
    assert_eq!(
        ::std::mem::size_of::<std___failure_type>(),
        1usize,
        concat!("Size of: ", stringify!(std___failure_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___failure_type>(),
        1usize,
        concat!("Alignment of ", stringify!(std___failure_type))
    );
}
pub struct Box_std___failure_type {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___failure_type {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size =
            ::std::cmp::max(1, ::std::mem::size_of::<std___failure_type>());
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___failure_type>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___failure_type {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___failure_type(
                self.ptr as *mut std___failure_type,
            );
            let size =
                ::std::cmp::max(1, ::std::mem::size_of::<std___failure_type>());
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___failure_type>(),
                )
                .unwrap(),
            );
        }
    }
}
pub type std___remove_cv_t = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_void_helper {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_void_helper_open0_void_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std___is_void_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_void_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_void_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_void_helper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_void {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_integral_helper {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_bool__close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_char_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_signed_char_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_char_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_wchar_t_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_char16_t_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_char32_t_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_short_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_short_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_int_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_int_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_long_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned_long_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0___int128_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_integral_helper_open0_unsigned___int128_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_integral_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_integral_helper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_integral {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_floating_point_helper {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_open0_float_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_open0_double_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_open0_long_double_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___is_floating_point_helper_open0___float128_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_floating_point_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_floating_point_helper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_floating_point {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_array {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_lvalue_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_rvalue_reference {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_object_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_object_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_function_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_function_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_enum {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_union {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_null_pointer_helper {
    pub _base: std_false_type,
}
#[test]
fn __bindgen_test_layout_std___is_null_pointer_helper_open0_nullptr_t_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___is_null_pointer_helper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___is_null_pointer_helper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___is_null_pointer_helper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___is_null_pointer_helper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_null_pointer {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nullptr_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_reference {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_arithmetic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_fundamental {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_object {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_scalar {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_compound {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_member_pointer_helper {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_member_pointer {
    pub _address: u8,
}
pub type std___is_one_of = std___or_;
pub type std___is_signed_integer = std___is_one_of;
pub type std___is_unsigned_integer = std___is_one_of;
pub type std___is_standard_integer = std___or_;
pub type std___void_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_referenceable {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_const {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_volatile {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivial {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copyable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_standard_layout {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_pod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_literal_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_polymorphic {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_final {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_abstract {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_signed {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_unsigned {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_known_bounds {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_array_unknown_bounds {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_destructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_destructible_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_is_destructible_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___do_is_destructible_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_is_destructible_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___do_is_destructible_impl))
    );
}
pub struct Box_std___do_is_destructible_impl {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___do_is_destructible_impl {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___do_is_destructible_impl>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___do_is_destructible_impl>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___do_is_destructible_impl {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___do_is_destructible_impl(
                self.ptr as *mut std___do_is_destructible_impl,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std___do_is_destructible_impl>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___do_is_destructible_impl>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_destructible_impl {
    pub _address: u8,
}
pub type std___is_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_nt_destructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_nt_destructible_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_is_nt_destructible_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___do_is_nt_destructible_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_is_nt_destructible_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___do_is_nt_destructible_impl)
        )
    );
}
pub struct Box_std___do_is_nt_destructible_impl {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___do_is_nt_destructible_impl {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___do_is_nt_destructible_impl>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___do_is_nt_destructible_impl>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___do_is_nt_destructible_impl {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___do_is_nt_destructible_impl(
                self.ptr as *mut std___do_is_nt_destructible_impl,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std___do_is_nt_destructible_impl>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___do_is_nt_destructible_impl>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nt_destructible_impl {
    pub _address: u8,
}
pub type std___is_nt_destructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_constructible_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_constructible {
    pub _address: u8,
}
pub type std___is_nothrow_constructible_impl = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nt_assignable_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_assignable_impl {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_is_implicitly_default_constructible_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___do_is_implicitly_default_constructible_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_is_implicitly_default_constructible_impl>(
        ),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___do_is_implicitly_default_constructible_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_is_implicitly_default_constructible_impl>(
        ),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___do_is_implicitly_default_constructible_impl)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt45__do_is_implicitly_default_constructible_impl6__testEz"]
    pub fn std___do_is_implicitly_default_constructible_impl___test(
    ) -> std_false_type;
}
impl std___do_is_implicitly_default_constructible_impl {
    #[inline]
    pub unsafe fn __test() -> std_false_type {
        std___do_is_implicitly_default_constructible_impl___test()
    }
}
pub struct Box_std___do_is_implicitly_default_constructible_impl {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___do_is_implicitly_default_constructible_impl {
    #[inline]
    pub fn __test() -> std_false_type {
        unsafe { std___do_is_implicitly_default_constructible_impl___test() }
    }
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<
                std___do_is_implicitly_default_constructible_impl,
            >(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<
                        std___do_is_implicitly_default_constructible_impl,
                    >(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___do_is_implicitly_default_constructible_impl {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___do_is_implicitly_default_constructible_impl(
                self.ptr
                    as *mut std___do_is_implicitly_default_constructible_impl,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<
                    std___do_is_implicitly_default_constructible_impl,
                >(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<
                        std___do_is_implicitly_default_constructible_impl,
                    >(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_impl {
    pub _address: u8,
}
pub type std___is_implicitly_default_constructible_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible_safe {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_implicitly_default_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_constructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_copy_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_move_assignable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_trivially_destructible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_has_virtual_destructor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_alignment_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_rank {
    pub _base: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_same {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_base_of {
    pub _address: u8,
}
pub type std___is_convertible_helper_type = std_is_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_convertible {
    pub _address: u8,
}
pub type std___is_array_convertible = std_is_convertible;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_convertible {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_const {
    pub _address: u8,
}
pub type std_remove_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_volatile {
    pub _address: u8,
}
pub type std_remove_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_const {
    pub _address: u8,
}
pub type std_add_const_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_volatile {
    pub _address: u8,
}
pub type std_add_volatile_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_cv {
    pub _address: u8,
}
pub type std_add_cv_type = std_add_const;
pub type std_remove_const_t = std_remove_const;
pub type std_remove_volatile_t = std_remove_volatile;
pub type std_remove_cv_t = std_remove_cv;
pub type std_add_const_t = std_add_const;
pub type std_add_volatile_t = std_add_volatile;
pub type std_add_cv_t = std_add_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_reference {
    pub _address: u8,
}
pub type std_remove_reference_type<_Tp> = _Tp;
pub type std___add_lvalue_reference_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_lvalue_reference {
    pub _address: u8,
}
pub type std___add_rvalue_reference_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_rvalue_reference {
    pub _address: u8,
}
pub type std_remove_reference_t = std_remove_reference;
pub type std_add_lvalue_reference_t = std_add_lvalue_reference;
pub type std_add_rvalue_reference_t = std_add_rvalue_reference;
pub type std___match_cv_qualifiers___type = std___match_cv_qualifiers___match;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned {
    pub _address: u8,
}
pub type std___make_unsigned___type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_signed_char_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_short_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_int_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_long_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_long_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0___int128_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_unsigned_selector_base {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___make_unsigned_selector_base() {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned_selector_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___make_unsigned_selector_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned_selector_base>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___make_unsigned_selector_base)
        )
    );
}
pub struct Box_std___make_unsigned_selector_base {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___make_unsigned_selector_base {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___make_unsigned_selector_base>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___make_unsigned_selector_base>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___make_unsigned_selector_base {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___make_unsigned_selector_base(
                self.ptr as *mut std___make_unsigned_selector_base,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std___make_unsigned_selector_base>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___make_unsigned_selector_base>(),
                )
                .unwrap(),
            );
        }
    }
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_wchar_t_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_char16_t_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_unsigned_open0_char32_t_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_unsigned>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_unsigned)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___make_signed {
    pub _address: u8,
}
pub type std___make_signed___type<_Tp> = _Tp;
#[test]
fn __bindgen_test_layout_std___make_signed_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_char_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_short_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_int_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned_long_long_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_unsigned___int128_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_wchar_t_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_char16_t_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[test]
fn __bindgen_test_layout_std___make_signed_open0_char32_t_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<std___make_signed>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std___make_signed)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___make_signed>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std___make_signed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_signed {
    pub _address: u8,
}
pub type std_make_signed_type = u8;
pub type std_make_signed_t = std_make_signed;
pub type std_make_unsigned_t = std_make_unsigned;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_extent {
    pub _address: u8,
}
pub type std_remove_extent_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_all_extents {
    pub _address: u8,
}
pub type std_remove_all_extents_type<_Tp> = _Tp;
pub type std_remove_extent_t = std_remove_extent;
pub type std_remove_all_extents_t = std_remove_all_extents;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___remove_pointer_helper {
    pub _address: u8,
}
pub type std___remove_pointer_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_pointer {
    pub _address: u8,
}
pub type std___add_pointer_helper_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_add_pointer {
    pub _address: u8,
}
pub type std_remove_pointer_t = std_remove_pointer;
pub type std_add_pointer_t = std_add_pointer;
#[repr(C)]
#[derive(Copy, Clone)]
pub union std___aligned_storage_msa___type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std___aligned_storage_msa___type__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___aligned_storage_msa___type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___aligned_storage_msa___type() {
    assert_eq!(
        ::std::mem::size_of::<std___aligned_storage_msa___type>(),
        8usize,
        concat!("Size of: ", stringify!(std___aligned_storage_msa___type))
    );
    assert_eq!(
        ::std::mem::align_of::<std___aligned_storage_msa___type>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std___aligned_storage_msa___type)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union std_aligned_storage_type {
    pub __data: *mut ::std::os::raw::c_uchar,
    pub __align: std_aligned_storage_type__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_aligned_storage_type__bindgen_ty_1 {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_aligned_storage_type() {
    assert_eq!(
        ::std::mem::size_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Size of: ", stringify!(std_aligned_storage_type))
    );
    assert_eq!(
        ::std::mem::align_of::<std_aligned_storage_type>(),
        8usize,
        concat!("Alignment of ", stringify!(std_aligned_storage_type))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strictest_alignment {
    pub _address: u8,
}
pub type std_aligned_union_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_decay {
    pub _address: u8,
}
pub type std_decay_type = u8;
pub type std___decay_t = std_decay;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reference_wrapper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___strip_reference_wrapper {
    pub _address: u8,
}
pub type std___strip_reference_wrapper___type<_Tp> = _Tp;
pub type std___decay_and_strip = std___strip_reference_wrapper;
pub type std___enable_if_t = u8;
pub type std__Require = std___enable_if_t;
pub type std_conditional_type<_Iftrue> = _Iftrue;
pub type std___remove_cvref_t = std_remove_cv;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_common_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___do_common_type_impl {
    pub _address: u8,
}
pub type std___do_common_type_impl___cond_t<_Tp> = _Tp;
#[test]
fn bindgen_test_layout_std___do_common_type_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___do_common_type_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___do_common_type_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___do_common_type_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___do_common_type_impl))
    );
}
pub struct Box_std___do_common_type_impl {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___do_common_type_impl {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___do_common_type_impl>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___do_common_type_impl>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___do_common_type_impl {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___do_common_type_impl(
                self.ptr as *mut std___do_common_type_impl,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std___do_common_type_impl>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___do_common_type_impl>(),
                )
                .unwrap(),
            );
        }
    }
}
#[test]
fn __bindgen_test_layout_std_common_type_open0_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_common_type>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_common_type)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_common_type>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_common_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_impl {
    pub _address: u8,
}
pub type std___common_type_impl_type = std_common_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_pack {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___common_type_fold {
    pub _address: u8,
}
pub type std___underlying_type_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_underlying_type {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___declval_protector {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_result_of {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_ref {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memfun_ref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memfun_ref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memfun_ref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memfun_ref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memfun_ref))
    );
}
pub struct Box_std___invoke_memfun_ref {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___invoke_memfun_ref {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___invoke_memfun_ref>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___invoke_memfun_ref>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___invoke_memfun_ref {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___invoke_memfun_ref(
                self.ptr as *mut std___invoke_memfun_ref,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std___invoke_memfun_ref>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___invoke_memfun_ref>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memfun_deref {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memfun_deref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memfun_deref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memfun_deref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memfun_deref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memfun_deref))
    );
}
pub struct Box_std___invoke_memfun_deref {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___invoke_memfun_deref {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___invoke_memfun_deref>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___invoke_memfun_deref>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___invoke_memfun_deref {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___invoke_memfun_deref(
                self.ptr as *mut std___invoke_memfun_deref,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std___invoke_memfun_deref>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___invoke_memfun_deref>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_ref {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memobj_ref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memobj_ref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memobj_ref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memobj_ref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memobj_ref))
    );
}
pub struct Box_std___invoke_memobj_ref {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___invoke_memobj_ref {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___invoke_memobj_ref>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___invoke_memobj_ref>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___invoke_memobj_ref {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___invoke_memobj_ref(
                self.ptr as *mut std___invoke_memobj_ref,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std___invoke_memobj_ref>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___invoke_memobj_ref>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_memobj_deref {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_memobj_deref() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_memobj_deref>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_memobj_deref))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_memobj_deref>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_memobj_deref))
    );
}
pub struct Box_std___invoke_memobj_deref {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___invoke_memobj_deref {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___invoke_memobj_deref>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___invoke_memobj_deref>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___invoke_memobj_deref {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___invoke_memobj_deref(
                self.ptr as *mut std___invoke_memobj_deref,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std___invoke_memobj_deref>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___invoke_memobj_deref>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_other {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___invoke_other() {
    assert_eq!(
        ::std::mem::size_of::<std___invoke_other>(),
        1usize,
        concat!("Size of: ", stringify!(std___invoke_other))
    );
    assert_eq!(
        ::std::mem::align_of::<std___invoke_other>(),
        1usize,
        concat!("Alignment of ", stringify!(std___invoke_other))
    );
}
pub struct Box_std___invoke_other {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___invoke_other {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size =
            ::std::cmp::max(1, ::std::mem::size_of::<std___invoke_other>());
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___invoke_other>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___invoke_other {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___invoke_other(
                self.ptr as *mut std___invoke_other,
            );
            let size =
                ::std::cmp::max(1, ::std::mem::size_of::<std___invoke_other>());
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___invoke_other>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_success {
    pub _address: u8,
}
pub type std___result_of_success___invoke_type<_Tag> = _Tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memfun_ref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memfun_ref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memfun_ref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memfun_ref_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___result_of_memfun_ref_impl))
    );
}
pub struct Box_std___result_of_memfun_ref_impl {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___result_of_memfun_ref_impl {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___result_of_memfun_ref_impl>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___result_of_memfun_ref_impl>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___result_of_memfun_ref_impl {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___result_of_memfun_ref_impl(
                self.ptr as *mut std___result_of_memfun_ref_impl,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std___result_of_memfun_ref_impl>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___result_of_memfun_ref_impl>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_ref {
    pub _address: u8,
}
pub type std___result_of_memfun_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memfun_deref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memfun_deref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memfun_deref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memfun_deref_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___result_of_memfun_deref_impl)
        )
    );
}
pub struct Box_std___result_of_memfun_deref_impl {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___result_of_memfun_deref_impl {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___result_of_memfun_deref_impl>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___result_of_memfun_deref_impl>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___result_of_memfun_deref_impl {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___result_of_memfun_deref_impl(
                self.ptr as *mut std___result_of_memfun_deref_impl,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std___result_of_memfun_deref_impl>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___result_of_memfun_deref_impl>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun_deref {
    pub _address: u8,
}
pub type std___result_of_memfun_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memobj_ref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memobj_ref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memobj_ref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memobj_ref_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___result_of_memobj_ref_impl))
    );
}
pub struct Box_std___result_of_memobj_ref_impl {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___result_of_memobj_ref_impl {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___result_of_memobj_ref_impl>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___result_of_memobj_ref_impl>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___result_of_memobj_ref_impl {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___result_of_memobj_ref_impl(
                self.ptr as *mut std___result_of_memobj_ref_impl,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std___result_of_memobj_ref_impl>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___result_of_memobj_ref_impl>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_ref {
    pub _address: u8,
}
pub type std___result_of_memobj_ref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_memobj_deref_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_memobj_deref_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_memobj_deref_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_memobj_deref_impl>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___result_of_memobj_deref_impl)
        )
    );
}
pub struct Box_std___result_of_memobj_deref_impl {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___result_of_memobj_deref_impl {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___result_of_memobj_deref_impl>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___result_of_memobj_deref_impl>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___result_of_memobj_deref_impl {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___result_of_memobj_deref_impl(
                self.ptr as *mut std___result_of_memobj_deref_impl,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std___result_of_memobj_deref_impl>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___result_of_memobj_deref_impl>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj_deref {
    pub _address: u8,
}
pub type std___result_of_memobj_deref_type<_MemPtr> = _MemPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memobj {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_memfun {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___inv_unwrap {
    pub _address: u8,
}
pub type std___inv_unwrap_type<_Tp> = _Tp;
pub type std___result_of_impl_type = std___failure_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___result_of_other_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___result_of_other_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___result_of_other_impl>(),
        1usize,
        concat!("Size of: ", stringify!(std___result_of_other_impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std___result_of_other_impl>(),
        1usize,
        concat!("Alignment of ", stringify!(std___result_of_other_impl))
    );
}
pub struct Box_std___result_of_other_impl {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___result_of_other_impl {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___result_of_other_impl>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___result_of_other_impl>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___result_of_other_impl {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___result_of_other_impl(
                self.ptr as *mut std___result_of_other_impl,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std___result_of_other_impl>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___result_of_other_impl>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___invoke_result {
    pub _address: u8,
}
pub type std_aligned_storage_t = u8;
pub type std_aligned_union_t = u8;
pub type std_decay_t = std_decay;
pub type std_enable_if_t = u8;
pub type std_conditional_t = u8;
pub type std_common_type_t = std_common_type;
pub type std_underlying_type_t = std_underlying_type;
pub type std_result_of_t = std_result_of;
pub type std_void_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_value_t = std_false_type;
pub type std___detector_type<_Default> = _Default;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like_impl {
    pub _base: std_false_type,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_tuple_like {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_swappable_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_details___do_is_swappable_impl() {
    assert_eq!(
        ::std::mem::size_of::<std___swappable_details___do_is_swappable_impl>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___swappable_details___do_is_swappable_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std___swappable_details___do_is_swappable_impl>(
        ),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___swappable_details___do_is_swappable_impl)
        )
    );
}
pub struct Box_std___swappable_details___do_is_swappable_impl {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___swappable_details___do_is_swappable_impl {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std___swappable_details___do_is_swappable_impl>(
            ),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<
                        std___swappable_details___do_is_swappable_impl,
                    >(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___swappable_details___do_is_swappable_impl {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___swappable_details___do_is_swappable_impl(
                self.ptr as *mut std___swappable_details___do_is_swappable_impl,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<
                    std___swappable_details___do_is_swappable_impl,
                >(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<
                        std___swappable_details___do_is_swappable_impl,
                    >(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_details___do_is_nothrow_swappable_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_details___do_is_nothrow_swappable_impl()
{
    assert_eq!(
        ::std::mem::size_of::<
            std___swappable_details___do_is_nothrow_swappable_impl,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(std___swappable_details___do_is_nothrow_swappable_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            std___swappable_details___do_is_nothrow_swappable_impl,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(std___swappable_details___do_is_nothrow_swappable_impl)
        )
    );
}
pub struct Box_std___swappable_details___do_is_nothrow_swappable_impl {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___swappable_details___do_is_nothrow_swappable_impl {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<
                std___swappable_details___do_is_nothrow_swappable_impl,
            >(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<
                        std___swappable_details___do_is_nothrow_swappable_impl,
                    >(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___swappable_details___do_is_nothrow_swappable_impl {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___swappable_details___do_is_nothrow_swappable_impl (self . ptr as * mut std___swappable_details___do_is_nothrow_swappable_impl) ;
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<
                    std___swappable_details___do_is_nothrow_swappable_impl,
                >(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<
                        std___swappable_details___do_is_nothrow_swappable_impl,
                    >(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable_impl {
    pub _address: u8,
}
pub type std___is_swappable_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable_impl {
    pub _address: u8,
}
pub type std___is_nothrow_swappable_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_swappable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_with_details___do_is_swappable_with_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_with_details___do_is_swappable_with_impl(
) {
    assert_eq!(
        ::std::mem::size_of::<
            std___swappable_with_details___do_is_swappable_with_impl,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(
                std___swappable_with_details___do_is_swappable_with_impl
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            std___swappable_with_details___do_is_swappable_with_impl,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                std___swappable_with_details___do_is_swappable_with_impl
            )
        )
    );
}
pub struct Box_std___swappable_with_details___do_is_swappable_with_impl {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___swappable_with_details___do_is_swappable_with_impl {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<
                std___swappable_with_details___do_is_swappable_with_impl,
            >(),
        );
        let ret = Self { ptr : :: std :: alloc :: alloc (:: std :: alloc :: Layout :: from_size_align (size , :: std :: mem :: align_of :: < std___swappable_with_details___do_is_swappable_with_impl > ()) . unwrap () ,) as * mut :: std :: ffi :: c_void , } ;
        ret
    }
}
impl Drop for Box_std___swappable_with_details___do_is_swappable_with_impl {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___swappable_with_details___do_is_swappable_with_impl (self . ptr as * mut std___swappable_with_details___do_is_swappable_with_impl) ;
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<
                    std___swappable_with_details___do_is_swappable_with_impl,
                >(),
            );
            :: std :: alloc :: dealloc (self . ptr as * mut u8 , :: std :: alloc :: Layout :: from_size_align (size , :: std :: mem :: align_of :: < std___swappable_with_details___do_is_swappable_with_impl > ()) . unwrap ()) ;
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___swappable_with_details___do_is_nothrow_swappable_with_impl {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___swappable_with_details___do_is_nothrow_swappable_with_impl(
) {
    assert_eq ! (:: std :: mem :: size_of :: < std___swappable_with_details___do_is_nothrow_swappable_with_impl > () , 1usize , concat ! ("Size of: " , stringify ! (std___swappable_with_details___do_is_nothrow_swappable_with_impl)));
    assert_eq ! (:: std :: mem :: align_of :: < std___swappable_with_details___do_is_nothrow_swappable_with_impl > () , 1usize , concat ! ("Alignment of " , stringify ! (std___swappable_with_details___do_is_nothrow_swappable_with_impl)));
}
pub struct Box_std___swappable_with_details___do_is_nothrow_swappable_with_impl
{
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___swappable_with_details___do_is_nothrow_swappable_with_impl {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = :: std :: cmp :: max (1 , :: std :: mem :: size_of :: < std___swappable_with_details___do_is_nothrow_swappable_with_impl > ()) ;
        let ret = Self { ptr : :: std :: alloc :: alloc (:: std :: alloc :: Layout :: from_size_align (size , :: std :: mem :: align_of :: < std___swappable_with_details___do_is_nothrow_swappable_with_impl > ()) . unwrap () ,) as * mut :: std :: ffi :: c_void , } ;
        ret
    }
}
impl Drop
    for Box_std___swappable_with_details___do_is_nothrow_swappable_with_impl
{
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___swappable_with_details___do_is_nothrow_swappable_with_impl (self . ptr as * mut std___swappable_with_details___do_is_nothrow_swappable_with_impl) ;
            let size = :: std :: cmp :: max (1 , :: std :: mem :: size_of :: < std___swappable_with_details___do_is_nothrow_swappable_with_impl > ()) ;
            :: std :: alloc :: dealloc (self . ptr as * mut u8 , :: std :: alloc :: Layout :: from_size_align (size , :: std :: mem :: align_of :: < std___swappable_with_details___do_is_nothrow_swappable_with_impl > ()) . unwrap ()) ;
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_swappable_with_impl {
    pub _address: u8,
}
pub type std___is_swappable_with_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_swappable_with_impl {
    pub _address: u8,
}
pub type std___is_nothrow_swappable_with_impl_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_swappable_with {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_nothrow_swappable_with {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___call_is_nothrow {
    pub _address: u8,
}
pub type std___call_is_nothrow_ = std___call_is_nothrow;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___is_nothrow_invocable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___nonesuchbase {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___nonesuchbase() {
    assert_eq!(
        ::std::mem::size_of::<std___nonesuchbase>(),
        1usize,
        concat!("Size of: ", stringify!(std___nonesuchbase))
    );
    assert_eq!(
        ::std::mem::align_of::<std___nonesuchbase>(),
        1usize,
        concat!("Alignment of ", stringify!(std___nonesuchbase))
    );
}
pub struct Box_std___nonesuchbase {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___nonesuchbase {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size =
            ::std::cmp::max(1, ::std::mem::size_of::<std___nonesuchbase>());
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___nonesuchbase>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___nonesuchbase {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___nonesuchbase(
                self.ptr as *mut std___nonesuchbase,
            );
            let size =
                ::std::cmp::max(1, ::std::mem::size_of::<std___nonesuchbase>());
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___nonesuchbase>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct std___nonesuch {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std___nonesuch() {
    assert_eq!(
        ::std::mem::size_of::<std___nonesuch>(),
        1usize,
        concat!("Size of: ", stringify!(std___nonesuch))
    );
    assert_eq!(
        ::std::mem::align_of::<std___nonesuch>(),
        1usize,
        concat!("Alignment of ", stringify!(std___nonesuch))
    );
}
pub struct Box_std___nonesuch {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std___nonesuch {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(1, ::std::mem::size_of::<std___nonesuch>());
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___nonesuch>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std___nonesuch {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std___nonesuch(self.ptr as *mut std___nonesuch);
            let size =
                ::std::cmp::max(1, ::std::mem::size_of::<std___nonesuch>());
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std___nonesuch>(),
                )
                .unwrap(),
            );
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___move_if_noexcept_cond {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_piecewise_construct_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_std_piecewise_construct_t() {
    assert_eq!(
        ::std::mem::size_of::<std_piecewise_construct_t>(),
        1usize,
        concat!("Size of: ", stringify!(std_piecewise_construct_t))
    );
    assert_eq!(
        ::std::mem::align_of::<std_piecewise_construct_t>(),
        1usize,
        concat!("Alignment of ", stringify!(std_piecewise_construct_t))
    );
}
pub struct Box_std_piecewise_construct_t {
    ptr: *mut ::std::ffi::c_void,
}
impl Box_std_piecewise_construct_t {
    #[inline]
    pub unsafe fn allocate_uninitialised() -> Self {
        let size = ::std::cmp::max(
            1,
            ::std::mem::size_of::<std_piecewise_construct_t>(),
        );
        let ret = Self {
            ptr: ::std::alloc::alloc(
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std_piecewise_construct_t>(),
                )
                .unwrap(),
            ) as *mut ::std::ffi::c_void,
        };
        ret
    }
}
impl Drop for Box_std_piecewise_construct_t {
    fn drop(&mut self) {
        unsafe {
            bindgen_destruct_std_piecewise_construct_t(
                self.ptr as *mut std_piecewise_construct_t,
            );
            let size = ::std::cmp::max(
                1,
                ::std::mem::size_of::<std_piecewise_construct_t>(),
            );
            ::std::alloc::dealloc(
                self.ptr as *mut u8,
                ::std::alloc::Layout::from_size_align(
                    size,
                    ::std::mem::align_of::<std_piecewise_construct_t>(),
                )
                .unwrap(),
            );
        }
    }
}
extern "C" {
    #[link_name = "\u{1}_ZStL19piecewise_construct"]
    pub static std_piecewise_construct: std_piecewise_construct_t;
}
#[repr(C)]
#[derive(Debug)]
pub struct std___pair_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug)]
pub struct std_pair<_T1, _T2> {
    pub first: _T1,
    pub second: _T2,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
}
pub type std_pair_first_type<_T1> = _T1;
pub type std_pair_second_type<_T2> = _T2;
pub type std_pair__PCCP = u8;
pub type std_pair__PCCFP = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_initializer_list<_E> {
    pub _M_array: std_initializer_list_iterator<_E>,
    pub _M_len: std_initializer_list_size_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_E>>,
}
pub type std_initializer_list_value_type<_E> = _E;
pub type std_initializer_list_reference<_E> = *const _E;
pub type std_initializer_list_const_reference<_E> = *const _E;
pub type std_initializer_list_size_type = std_size_t;
pub type std_initializer_list_iterator<_E> = *const _E;
pub type std_initializer_list_const_iterator<_E> = *const _E;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_tuple_size {
    pub _address: u8,
}
pub type std___enable_if_has_tuple_size<_Tp> = _Tp;
pub type std___tuple_element_t = u8;
pub type std_tuple_element_t = u8;
pub type std__Build_index_tuple__IdxTuple = u8;
pub type std__Build_index_tuple___type = u8;
pub type std_integer_sequence_value_type<_Tp> = _Tp;
pub type std_make_integer_sequence = u8;
pub type std_index_sequence = u8;
pub type std_make_index_sequence = std_make_integer_sequence;
pub type std_index_sequence_for = std_make_index_sequence;
extern "C" {
    #[link_name = "\u{1}_Z25bindgen_destruct_or_throwPv"]
    pub fn bindgen_destruct_or_throw(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_Z35bindgen_destruct_std___failure_typePSt14__failure_type"]
    pub fn bindgen_destruct_std___failure_type(ptr: *mut std___failure_type);
}
extern "C" {
    #[link_name = "\u{1}_Z46bindgen_destruct_std___do_is_destructible_implPSt25__do_is_destructible_impl"]
    pub fn bindgen_destruct_std___do_is_destructible_impl(
        ptr: *mut std___do_is_destructible_impl,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z49bindgen_destruct_std___do_is_nt_destructible_implPSt28__do_is_nt_destructible_impl"]
    pub fn bindgen_destruct_std___do_is_nt_destructible_impl(
        ptr: *mut std___do_is_nt_destructible_impl,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z66bindgen_destruct_std___do_is_implicitly_default_constructible_implPSt45__do_is_implicitly_default_constructible_impl"]
    pub fn bindgen_destruct_std___do_is_implicitly_default_constructible_impl(
        ptr: *mut std___do_is_implicitly_default_constructible_impl,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z50bindgen_destruct_std___make_unsigned_selector_basePSt29__make_unsigned_selector_base"]
    pub fn bindgen_destruct_std___make_unsigned_selector_base(
        ptr: *mut std___make_unsigned_selector_base,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z42bindgen_destruct_std___do_common_type_implPSt21__do_common_type_impl"]
    pub fn bindgen_destruct_std___do_common_type_impl(
        ptr: *mut std___do_common_type_impl,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z40bindgen_destruct_std___invoke_memfun_refPSt19__invoke_memfun_ref"]
    pub fn bindgen_destruct_std___invoke_memfun_ref(
        ptr: *mut std___invoke_memfun_ref,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z42bindgen_destruct_std___invoke_memfun_derefPSt21__invoke_memfun_deref"]
    pub fn bindgen_destruct_std___invoke_memfun_deref(
        ptr: *mut std___invoke_memfun_deref,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z40bindgen_destruct_std___invoke_memobj_refPSt19__invoke_memobj_ref"]
    pub fn bindgen_destruct_std___invoke_memobj_ref(
        ptr: *mut std___invoke_memobj_ref,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z42bindgen_destruct_std___invoke_memobj_derefPSt21__invoke_memobj_deref"]
    pub fn bindgen_destruct_std___invoke_memobj_deref(
        ptr: *mut std___invoke_memobj_deref,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z35bindgen_destruct_std___invoke_otherPSt14__invoke_other"]
    pub fn bindgen_destruct_std___invoke_other(ptr: *mut std___invoke_other);
}
extern "C" {
    #[link_name = "\u{1}_Z48bindgen_destruct_std___result_of_memfun_ref_implPSt27__result_of_memfun_ref_impl"]
    pub fn bindgen_destruct_std___result_of_memfun_ref_impl(
        ptr: *mut std___result_of_memfun_ref_impl,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z50bindgen_destruct_std___result_of_memfun_deref_implPSt29__result_of_memfun_deref_impl"]
    pub fn bindgen_destruct_std___result_of_memfun_deref_impl(
        ptr: *mut std___result_of_memfun_deref_impl,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z48bindgen_destruct_std___result_of_memobj_ref_implPSt27__result_of_memobj_ref_impl"]
    pub fn bindgen_destruct_std___result_of_memobj_ref_impl(
        ptr: *mut std___result_of_memobj_ref_impl,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z50bindgen_destruct_std___result_of_memobj_deref_implPSt29__result_of_memobj_deref_impl"]
    pub fn bindgen_destruct_std___result_of_memobj_deref_impl(
        ptr: *mut std___result_of_memobj_deref_impl,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z43bindgen_destruct_std___result_of_other_implPSt22__result_of_other_impl"]
    pub fn bindgen_destruct_std___result_of_other_impl(
        ptr: *mut std___result_of_other_impl,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z63bindgen_destruct_std___swappable_details___do_is_swappable_implPNSt19__swappable_details22__do_is_swappable_implE"]
    pub fn bindgen_destruct_std___swappable_details___do_is_swappable_impl(
        ptr: *mut std___swappable_details___do_is_swappable_impl,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z71bindgen_destruct_std___swappable_details___do_is_nothrow_swappable_implPNSt19__swappable_details30__do_is_nothrow_swappable_implE"]
    pub fn bindgen_destruct_std___swappable_details___do_is_nothrow_swappable_impl(
        ptr: *mut std___swappable_details___do_is_nothrow_swappable_impl,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z73bindgen_destruct_std___swappable_with_details___do_is_swappable_with_implPNSt24__swappable_with_details27__do_is_swappable_with_implE"]
    pub fn bindgen_destruct_std___swappable_with_details___do_is_swappable_with_impl(
        ptr: *mut std___swappable_with_details___do_is_swappable_with_impl,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z81bindgen_destruct_std___swappable_with_details___do_is_nothrow_swappable_with_implPNSt24__swappable_with_details35__do_is_nothrow_swappable_with_implE"]
    pub fn bindgen_destruct_std___swappable_with_details___do_is_nothrow_swappable_with_impl(
        ptr : * mut std___swappable_with_details___do_is_nothrow_swappable_with_impl,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z35bindgen_destruct_std___nonesuchbasePSt14__nonesuchbase"]
    pub fn bindgen_destruct_std___nonesuchbase(ptr: *mut std___nonesuchbase);
}
extern "C" {
    #[link_name = "\u{1}_Z31bindgen_destruct_std___nonesuchPSt10__nonesuch"]
    pub fn bindgen_destruct_std___nonesuch(ptr: *mut std___nonesuch);
}
extern "C" {
    #[link_name = "\u{1}_Z42bindgen_destruct_std_piecewise_construct_tPSt21piecewise_construct_t"]
    pub fn bindgen_destruct_std_piecewise_construct_t(
        ptr: *mut std_piecewise_construct_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_2 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_3 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_4 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_5 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_6 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_7 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_8 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_9 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_10 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_11 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_12 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_13 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_14 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_15 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_16 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_17 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_18 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_19 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_20 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_21 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_22 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_23 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_24 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_25 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_26 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_27 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_28 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_29 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_30 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_31 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_32 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_33 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_34 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_35 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_36 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_37 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_38 {
    pub _address: u8,
}
}
use bindgen_bindings::*;
